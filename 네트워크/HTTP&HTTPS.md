## HTTP&HTTPS

### HTTP
> 인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약 <br/>
> TCP/IP 기반으로 서버와 클라이언트 간의 요청과 응답을 전송한다. 

#### 특징

* 비연결성
  * 브라우저를 통해 사용자의 요청으로 서버와 접속하여 요청에 대한 응답의 데이터를 전송 후, 연결을 종료한다. 
  
* 단방향성
  * 사용자의 요청 한 개에 대해 한 개의 응답을 하는 방식 -> 서버가 먼저 응답하지 않는다. 

#### 단점 

* 텍스트 교환이므로, 누군가 네트워크에서 신호를 가로채면 내용이 노출될 수 있는 보안 이슈가 존재한다. 
* 평문이므로, 도청이 가능하다. 
* 통신 상대를 확인하지 않으므로 위장이 가능하다. 


-> 이러한 **보안 문제**를 해결해주는 프로토콜이 ***HTTPS***이다. 

<br/>

### HTTPS
> 인터넷 상에서 정보를 암호화하는 **SSL(Secure Socket Layer) 프로토콜**을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약 <br/>
> HTTP + 암호화, 인증, 안전성 보호 

HTTP는 **TCP**와 통신 <br/>
HTTPS는 **HTTP<->SSL** 통신 + **SSL<->TCP** 통신 

#### HTTPS의 SSL
* 하이브리드 암호화 시스템 
  * 대칭키 암호화 방식 + 공개키 암호화 방식 <br/>
    대칭키를 공개키 암호화 방식으로 교환한 다음에 그 다음부터의 통신은 대칭키 암호를 사용하는 방식 
        
    ```
    1. A가 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하고 B에게 보냄
    2. B는 암호문을 받고, 자신의 비밀키로 복호화함
    3. B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화하여 A에게 보냄
    4. A는 자신의 대칭키로 암호문을 복호화함
    5. 앞으로 이 대칭키로 암호화를 통신함
    ```
    
#### 비교 
* 평문 통신에 비해서 암호화 통신은 CPU, 메모리 등의 자원을 더 많이 요구한다. 
* 하지만 요즘에는 하드웨어의 발달로 HTTPS를 사용하더라도 속도 저하가 거의 없음. HTTP 2.0을 사용 시에는 오히려 빠르게 동작할 때도 있음. 
* 요즘에는 거의 HTTPS 방식 사용 

<br/>

#### HTTPS 통신 흐름

```
1. 애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해 공개키와 개인키를 만든다. 

2. 신뢰할 수 있는 CA(Certificate Authority/ 공개키를 저장해주는 신뢰성이 검증된 민간기업)기업을 선택하고 내 공개키 관리를 부탁하며 계약을 한다. 

3. 계약 완료된 CA 기업은 해당 기업의 이름, A서버 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공한다. 

4. A서버는 암호화된 인증서를 갖게 되었다. 이제 A서버는 A서버 공개키로 암호화된 HTTPS요청이 아닌 요청이 오면, 이 암호화된 인증서를 클라이언트에게 건내준다.

5. 클라이언트가 main.html 파일을 달라고 A서버에 요청했다고 가정하자. HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA기업의 개인키로 암호화한 인증서를 받게 된다.
   CA기업의 공개키는 브라우저가 이미 알고 있다. 
        
6. 브라우저는 해독한 뒤 A서버의 공개키를 얻게 되었다. 

7. 클라이언트가 A서버와 HandShaking과정에서 주고받은 난수를 조합하여 대칭키를 생성한 뒤, A서버의 공개키로 해당 대칭키를 암호화하여 서버로 보낸다. 

8. A서버는 암호화된 대칭키를 자신의 개인키로 복호화하여 클라이언트와 동일한 대칭키를 획득한다. 

9. 이후 클라이언트-서버 사이의 통신을 할 때 주고받는 메세지는 이 대칭키를 이용하여 암호화, 복호화를 진행한다. 

HTTPS도 무조건 안전한 것은 아니다. (신뢰받는 CA 기업이 아닌 자체 인증서 발급한 경우 등)
이때는 HTTPS지만 브라우저에서 주의 요함, 안전하지 않은 사이트와 같은 알림으로 주의 받게 된다.
```
