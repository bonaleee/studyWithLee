## 1. 웹서버와의 통신과정
브라우저의 주요 기능 중 하나는 클라이언트(사용자)가 자원을 서버에 요청하고 받은 자원을 브라우저에 표시하는 것이다. </br>
웹 브라우저에 URL을 입력하면 웹 서버가 브라우저에 웹 페이지를 제공하는 것이다. </br>
이 때의 요청을 Request(웹페이지를 달라고 하는 것) 응답을 Response(웹페이지를 웹브라우저에 제공)이라 한다. </br>
</br>
일반적으로 웹 브라우저와 웹 서버는 다른 컴퓨터에 위치한다. 그래서 연결하기 위해서 **IP 주소**가 필요하다. </br>
IP주소라고 하면 192.168.0.1 처럼 숫자 형태인데 이를 좀 더 쉽게 활용하기 위해 "github.com"과 같은 도메인을 활용하는 것이다. </br>
도메인의 이름을 IP주소로 변환할 때 사용하는 것이 **DNS(Domain Name Server)** 이다. </br> 

웹 브라우저에서 URL(도메인)을 입력하면 웹브라우저는 도메인 이름에 해당하는 IP 주소를 DNS에 요청한다.  </br>
그리고 DNS는 IP주소를 응답으로 제공한다.  </br>
DNS로 IP주소를 받는다면, 웹서버에 연결하여 웹페이지를 요청하고 응답받게 되는 것이다.

## 2. 브라우저의 기본 기조
브라우저의 구성 요소들을 다음과 같다. </br></br>
![image](https://user-images.githubusercontent.com/32945436/227839111-92ff1ee7-653a-425c-a5d9-b212093d8988.png)
- 사용자 인터페이스 : 주소표시줄, 이전과 다음 버튼, 북마크, 새로고침, 중단, 홈 버튼 등
- 브라우저 엔진 : 사용자 인터페이스와 렌더링 엔진 사이 동작을 제어.
- 렌더링 엔진 : HTML, CSS를 파싱해서 화면에 요청한 컨텐츠를 표시
- 통신 : HTTP와 같은 네트워크 호출에 사용
- JS 엔진 : JS 코들르 해석하고 실행
- UI 백엔드 : 플랫폼에서 명시하지 않은 일반적 인터페이스. 콤보 박스 창같은 기본적 장치를 그림
- 자료 저장소 : 쿠키 등 모든 종류의 자원을 하드 디스크에 저장하는 계층

## 3. 렌더링 엔진
렌더링 엔진은 요청받은 내용을 브라우저 화면에 표시해준다. </br>
브라우저마다 렌더링 엔진이 달라, 가끔 호환의 문제가 발생하는 것이다. </br>
- 크롬, 사파리 : 웹킷(WebKit) 엔진 사용</br> 크롬의 경우 웹킷을 사용하다가 웹킷을 fork 하여 블링크 엔진을 자체적으로 구현하여 사용한다고 함.
- 파이어 폭스 : 게코(Gecko) 엔진 사용

## 4. 렌더링 엔진 동작과정
![image](https://user-images.githubusercontent.com/32945436/227840256-75ab22b1-15ca-4e9e-b19f-caa85220e339.png)</br>
- DOM이란?
Document Object Model(문서 객체 모델)</br>
```<html> <body>```와 같은 태그들이 있는데 이를 JS가 활용할 수 있는 객체로 만들면 문서 객체가 되는 것이다. </br>
모델은, 모듈화로 만들거나 객체를 인식했다라고 해석하면 되는 것이므로 </br>
웹브라우저가 html 페이지를 인식하는 방식이라고 이해하면 된다.

### DOM(Document Object Model), CSSOM(CSS Object Model) 생성 (Parsing)
![image](https://user-images.githubusercontent.com/32945436/227841177-e123ae32-f261-4f0f-8ac8-36f0b269a5a6.png)</br>
- HTML을 파싱하여 DOM 노드를 만든다. 이들을 병합하여 DOM 트리 생성
- CSS를 파싱하여 CSSOM 트리를 만든다. </br>
브라우저는 HTML과 CSS를 나눠서 읽게되는 것이며, 이를 파싱을 통해 단순한 텍스트가 아닌 관리가 가능한 객체 모델로 만드는 것이다.</br>
렌더링 엔진은 모든  HTML 을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작하는데 이래서 일부화면이 먼저 표시되는 것이다.

### 렌더 트리 구축 (Attachment)
![image](https://user-images.githubusercontent.com/32945436/227842006-2a4b0291-f715-4b25-9cf2-6924d47d0ca8.png) </br>
CSSOM 트리와 DOM 트리를 결합해서 표시해야할 순서로 내용을 그릴 수 있도록 렌더 트리를 형성한다. 이것이 Attachment 라고 한다. </br>
렌더 트리는 화면에 표시되는 각 노드의 위치를 계산하는 레이아웃에 사용되고 픽셀을 화면에 그리는 페인트 과정에도 사용.</br>
![image](https://user-images.githubusercontent.com/32945436/227842162-a7c40712-d400-4e43-9c4b-5e1c2a14c433.png)</br>
렌더트리를 생성하기 위해 브라우저 작업을 수행한다.
- DOM 트리의 루트부터 노드를 모두 탐색.
- meta 태그와 같이 화면에 보이지 않는 것들과 display:none같은 것들은 반영되지 않는다.
- 화면에 표시되는 각 노드에 대해 적절하게 일치하는 CSSOM 규칙을 찾아서 적용
- 화면에 표시되는 노드들을 계산된 스타일과 함께 렌더트리로 생성

### 렌더 트리 배치 (Layout or Reflow)
![image](https://user-images.githubusercontent.com/32945436/227842564-eac81b0c-f77f-4c9f-bcc5-cc585ff2551a.png) </br>
렌더 트리가 생성되고, 기기의 뷰포트 내에서 렌더 트리의 노드가 정확한 위치와 크기를 계산한다. </br>
이때 모든 상대적인 값이 픽셀값으로 변환된다. </br>
CSS에 상대적인 값인 ```%,rem,vh```으로 할당된 값들은 절대적인 값인 px단위로 변환 된다. </br>
이 과정을 배치(Layout) 또는 Reflow 라고 한다.

### 렌더 트리 그리기 (Paint)
![image](https://user-images.githubusercontent.com/32945436/227842720-ba28afa1-993f-4110-83f3-233edd9c4a90.png) </br>
렌더트리의 각 노드들들 화면의 실제 픽셀로 그릴 때 Painting 메소드가 호출되며, 이후 UI가 브라우저에 표시된다.

#### 그리기 순서
- 배경색  -> 배경 이미지 -> 테두리 -> 자식 -> 아웃라인

### Reflow
- 렌더 트리와 각 요소들의 크기와 위치를 다시 계산해주는 것이 Reflow이다.
Reflow는 다음과 같은 경우에 일어나는데
- DOM 노드의 추가, 제거, 위치변경, 크기변경(margin,padding,width) 
- CSS 애니메이션과 트랜지션
- 폰트 변경, 텍스트 내용 변경
- 이미지 크기 변경
- offset, scrollTop와 같은 계산된 스타일 정보 요청
- 페이지 초기 렌더링
- 윈도우 리사이징 </br></br>

Reflow가 발생하면 Repaint가 발생해서 렌더링 최적화에 좋지않음, 따라서 Reflow는 최소화 할 수 있도록 해야함.

### 요약
- 주소창에 URL을 입력하면 서버에 요청이 전송
- 해당 페이지에 존재하는 여러 자원(텍스트, 이미지)등이 보내짐
- 브라우저는 자원이 담긴 html과 스타일이 담긴 css를 해석함(렌더링엔진으로)
- 이 때 html 파싱을 먼저해서 DOM 트리 구축
- 그 다음 css 파싱을 통해 CSSOM 트리 구축
- 이 두 가지를 합쳐 렌더트리 만듬
- 배치를 한 후 그리기를 함
- 일부분 진행하면서 조금씩 화면에 표시

[참고자료] </br>
https://d2.naver.com/helloworld/59361 </br>
https://velog.io/@thyoondev/%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90
