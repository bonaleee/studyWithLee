# B-Tree

인덱스를 이루고 있는 자료 구조의 일종.  
이진트리에서 발전되어 **모든 리프노드들이 같은 레벨**을 가질 수 있도록 자동으로 밸런스를 맞추는 트리이다.  
또한, 정렬된 순서를 보장하고, 멀티레벨 인덱싱을 통한 빠른 검색을 할 수 있어 DB에서 사용하는 자료구조 중 한 종류이다.

B트리는 이진트리와 다르게 하나의 노드에 많은 수의 정보를 가지고 있을 수 있다. 최대 M개의 자식을 가질 수 있는 B트리를 M차 B트리라고 하며 다음과 같은 특징이 있다.

- 노드는 최대 M개 부터 M/2개 까지의 자식을 가질 수 있다.
- 노드에는 최대 M−1개 부터 (M/2)−1개의 키가 포함될 수 있다.
- 노드의 키가 x개라면 자식의 수는 x+1개 이다.
- 최소차수는 자식수의 하한값을 의미하며, 최소차수가 t라면 M=2t−1을 만족한다.  
   (최소차수 t가 2라면 3차 B트리이며, key의 하한은 1개이다.)

![image](https://velog.velcdn.com/images%2Femplam27%2Fpost%2Fddbae2c9-da94-457d-bad8-77ff6791255b%2FB%ED%8A%B8%EB%A6%AC%20%EA%B8%B0%EB%B3%B8%20%ED%98%95%ED%83%9C.png)

## 키 검색

루트노드에서 시작하여 **하향식으로 검색**을 수행한다.

**검색하고자 하는 Key가 k일 때의 검색 과정**

1. 루트 노드에서 시작하여 key들을 순회하면서 검사한다.  
   1-1. 만일 k와 같은 key를 찾았다면 검색을 종료한다.  
   1-2. 검색하는 값과 key들의 대소관계를 비교한다. 어떠한 key들 사이에 k가 들어간다면 해당 key들 사이의 자식노드로로 내려간다.

2. 해당 과정을 리프노드에 도달할 때까지 반복한다. 만일 리프노드에도 k와 같은 key가 없다면 검색을 실패한다.

![image](https://velog.velcdn.com/images%2Femplam27%2Fpost%2Fb7df8287-2524-4ec0-ad03-b969a8830c8e%2FB%ED%8A%B8%EB%A6%AC%20%EA%B2%80%EC%83%89%201.png)
![image](https://velog.velcdn.com/images%2Femplam27%2Fpost%2Fe20bdef7-e106-4c89-9560-d7f57154dce1%2FB%ED%8A%B8%EB%A6%AC%20%EA%B2%80%EC%83%89%202.png)

## 키 삽입

키의 삽입은 먼저 요소 삽입에 적절한 리프 노드를 검색하고 필요한 경우 노드를 분할하게 된다.  
이 때 **검색은 하향식**으로 진행되지만 **분할은 상향식**으로 이루어진다.

삽입하고자 하는 Key가 k일 때의 삽입 과정.

1. 트리가 비어있으면 루트 노드를 할당하고 k를 삽입한다. 만일 루트노드가 가득 찼다면, 노드를 분할하고 리프노드가 생성된다.

2. 이후부터는 삽입하기에 적절한 리프노드를 찾아 k를 삽입합니다. 삽입위치는 노드의 key값과 k값을 검색 연산과 동일한 방법으로 비교하면서 찾는다.

3. 3-1. 리프노드가 가득차지 않았다면, 오름 차순으로 k를 삽입하고 종료한다.
   3-2. 리프노드가 가득찬 상태라면 노드를 분할하는 4번 과정을 진행한다.

4. 중앙값에서 분할을 수행한다. 중앙값은 부모 노드로 병합되거나 새로 생성된다.

5. 부모 노드를 검사해서 또 다시 가득 찼다면, 부모 노드에서도 4번을 반복한다.

## 키 삭제

요소를 삭제하기 위해선 3단계에 걸쳐 삭제한다.

1. 삭제할 키가 있는 노드 검색.
2. 키 삭제
3. 필요한 경우, 트리 균형 조정

### 삭제할 키 k가 리프에 있는 경우

- 현재 노드의 키 개수가 최소 키 개수보다 크다면 다른 노드에 영향이 없으므로 단순 삭제한다.

- 왼쪽 또는 오른쪽 형제 노드의 키가 최소 키 개수 이상이라면

  1. 부모 key 값으로 k를 대체한다.
  2. 최소키 개수 이상의 키를 가진 형제 노드가 왼쪽 형제라면 가장 큰 값을, 오른쪽 형제라면 가장 작은 값을 부모key로 대체한다.
     ![image](https://velog.velcdn.com/images%2Femplam27%2Fpost%2F8e7b0f78-ae26-48df-8925-47171c588c48%2FB%ED%8A%B8%EB%A6%AC%20%EC%82%AD%EC%A0%9C%201-2.png)

- 왼쪽, 오른쪽 형제 노드의 키가 최소 키 개수이고, 부모노드의 키가 최소개수 이상이면
  1. k를 삭제한 후, 부모key를 형제 노드와 병합한다.
  2. 부모노드의 key개수를 하나 줄이고, 자식 수 역시 하나를 줄여 B-Tree를 유지한다.
     ![image](https://velog.velcdn.com/images%2Femplam27%2Fpost%2Fdde5e5ae-892c-4d1c-9299-4710023f7531%2FB%ED%8A%B8%EB%A6%AC%20%EC%82%AD%EC%A0%9C%201-3.png)

### 삭제할 키 k가 내부 노드에 있고, 노드나 자식에 키가 최소 키수보다 많을 경우

1. 현재 노드의 inorder predecessor 또는 inorder successor와 k의 자리를 바꾼다.
2. 리프노드의 k를 삭제하게 되면, 리프노드가 삭제 되었을 때의 조건으로 변한다.
   ![image](https://velog.velcdn.com/images%2Femplam27%2Fpost%2F6d4a5d37-1633-45a1-8225-c6e558031865%2FB%ED%8A%B8%EB%A6%AC%20%EC%82%AD%EC%A0%9C%202.png)

### 삭제할 키 k가 내부 노드에 있고, 노드에 key 개수가 최소key 개수만큼, 노드의 자식 key 개수도 모두 최소 key 개수인 경우

삭제할 key k가 있는 노드도 최소, 자식노드들도 최소의 key 개수를 가지므로, k를 삭제하면 트리의 높이가 줄어들어 **재구조화**가 일어나는 케이스이다. 재구조화의 과정은 다음과 같다.

1. k를 삭제하고, k의 양쪽 자식을 병합하여 하나의 노드로 만듭니다.

2. k의 부모key를 인접한 형제 노드에 붙입니다. 이후, 이전에 병합했던 노드를 자식노드로 설정합니다.

3. 3-1. 만일 새로 구성된 인접 형제노드의 key가 최대 key 개수를 넘어갔다면, 삽입 연산의 노드 분할 과정을 수행합니다.
   3-2. 만일 인접 형제노드가 새로 구성되더라도 원래 k의 부모 노드가 최소 key의 개수보다 작아진다면, 부모 노드에 대하여 2번 과정부터 다시 수행합니다.
   ![image](https://velog.velcdn.com/images%2Femplam27%2Fpost%2Fe2f82f30-2f9c-4177-a908-1b5333f8e9d6%2FB%ED%8A%B8%EB%A6%AC%20%EC%82%AD%EC%A0%9C%203-2.png)

</br>

# B+Tree

B-Tree의 확장개념으로, 브랜치 노드에는 key만 담아두고 데이터는 담지 않는다. 오직 리프 노드에서만 key와 데이터를 저장하고, 리프 노드끼리 Linked list로 연결되어 있는 Tree구조이다.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbRiL19%2FbtqBTMSBCWF%2FJ3nKw2qympUVxGThnVdLK0%2Fimg.png)

## B+Tree의 장점

1. 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용할 수 있다. 하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 더 낮아진다.(cache hit를 높일 수 있음)

2. 풀 스캔 시, B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다. B-tree의 경우에는 모든 노드를 확인해야 한다.

## InnoDB B+Tree

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCbs9b%2FbtqBVf7DVW2%2F8JOOKlHiwkoTsqbvbTt7R1%2Fimg.png)
