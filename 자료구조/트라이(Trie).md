# 트라이(Trie) 구조

문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조.

**자동완성, 사전 검색** 등 문자열을 탐색하는데 특화 되어있는 자료구조이다.

![image](https://camo.githubusercontent.com/7024b55e64516062054e9b5bccf35dc72d5e7a4cca88c8f57810804b955cb849/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323433353445333335383333413743463137)

</br>

## 삽입 예제

- **'abc'를 Trie에 삽입**
  1. 첫 번째 문자는 'a'이다. 초기에 트라이 자료구조 내에는 아무것도 없으므로 Head의 자식노드에 'a'를 추가해준다.
  2. 'a'노드에도 현재 자식이 하나도 없으므로, 'a'의 자식노드에 'b'를 추가해준다.
  3. 'c'도 마찬가지로 'b'의 자식노드로 추가해준다.
  4. 'abc' 단어가 여기서 끝남을 알리기 위해 현재 노드에 abc라고 표시한다. (Data)

</br>

![image](https://velog.velcdn.com/images%2Fkimdukbae%2Fpost%2Fff402294-b59d-4866-910e-2b3ba4c423cb%2Fimage.png)

</br>

- **'car'를 Trie에 삽입**
  1. Head의 자식노드로 'a'만 존재하고, 'c'는 존재하지 않는다. 따라서 'c'를 자식노드로 추가한다.
  2. 'c'의 자식노드가 없으므로 마찬가지로 'a'를 추가한다.
  3. 'a'의 자식노드가 없으므로 마찬가지로 'r'을 추가한다.
  4. 'car' 단어가 여기서 끝이므로 현재 노드에 car를 표시한다.

</br>

![image](https://velog.velcdn.com/images%2Fkimdukbae%2Fpost%2F8d819895-5389-4b31-8b6b-a133e4ab3396%2Fimage.png)

</br>

## 탐색 예제

위에서 삽입한 데이터를 바탕으로 문자열 탐색을 진행해보자.

![image](https://velog.velcdn.com/images%2Fkimdukbae%2Fpost%2Fbc255f08-81f6-4031-8ac6-ca8f465ca7a3%2Fimage.png)

- 'abc'문자열 탐색

  1. Head의 child에 'a'가 존재 --> 'a'노드(key='a')로 이동
  2. 'a'노드의 child에 'b'가 존재 --> 'b'노드(key='b')로 이동
  3. 'b'노드의 child에 'c'가 존재 --> 'c'노드(key='c')로 이동
  4. 문자열 탐색이 완료됨 --> 현재 노드('c'노드)에 Data값이 존재! --> 따라서 'abc'라는 문자열이 존재함을 알 수 있음

</br>

- 'ca'문자열 탐색
  1. Head의 child에 'c'가 존재 --> 'c'노드(key='c')로 이동
  2. 'c'노드의 child에 'a'가 존재 --> 'a'노드(key='a')로 이동
  3. 문자열 탐색이 완료됨 --> 현재 노드('a'노드)에 Data값이 없음! --> 따라서 'ca'라는 문자열은 존재 X

</br>

## 시간 복잡도

L : 가장 긴 문자열의 길이.  
M : 문자열 개수.

생성 시간 복잡도 : **O(ML)**  
탐색 시간 복잡도 : **O(L)**  
삽입 시간 복잡도 : **O(L)**
