# 운영체제 
> 시스템의 자원(CPU, 메모리 등)과 동작을 관리하는 소프트웨어 <br/>
> 프로세스, 저장장치(RAM, HDD), 네트워킹, 사용자, 하드웨어를 관리 

## 메모리(RAM) 구조
메모리 공간 종류 4가지: Code, Data, Heap, Stack

<br/>

- **프로그램 실행 과정** 
<p align="center"><img width="650" src="https://user-images.githubusercontent.com/29995318/228402701-7139bad3-65f6-4e85-a587-a9c7040dd856.png"></p>

- **메모리 공간** 
<p align="center"><img width="350" src="https://user-images.githubusercontent.com/29995318/228402985-679891ca-2973-47b6-976b-967d8ecf4de5.png"></p>

<br/>

**컴파일 타임** : 개발자가 작성한 소스코드가 컴파일을 통해서 기계가 읽을 수 있는 형태(기계어코드)로 변환되는 과정 <br/>
**런 타임** : 컴파일 타임 이후 사용자에 의해 응용프로그램이 동작되어지는 때 

<br/>

### 메모리 구조에 대해서 설명해보세요. 
메모리에는 크게 네가지 종류가 있습니다. Code, Data, Heap, Stack이 있구요, 각각 Code는 소스코드가 들어가는 부분이고, Data는 전역변수, 정적변수가 할당되는 부분이에요. 그리고 Heap은 사용자가 직접 관리하는 영역으로 데이터가 동적으로 할당되는 공간이구요, Stack은 함수의 호출정보, 지역변수, 매개변수들이 저장되게 된다. 

<br/>
<br/>

## 프로세스, 스레드 
> 프로세스 : 실행중인 프로그램 <br/>
> 스레드 : 프로세스 안 실행 단위 

<br/>

<p align="center"><img width="500" src="https://user-images.githubusercontent.com/29995318/228405166-b1bfd901-445f-4529-95db-adb1b080ad76.png"></p>

**프로세스**는 각각 독립된 메모리 영역을 할당받는다. 

<p align="center"><img width="500" src="https://user-images.githubusercontent.com/29995318/228405472-4f83cd49-d314-4934-b153-da9a79ec84f0.png"></p>

**스레드**는 프로세스 내에서 각각 Stack만 따로 할당받고, Code, Data, Heap 영역은 공유한다. 

<br/>

### 프로세스와 스레드에 대해서 설명해보세요. 
프로세스는 실행 중인 프로그램이구요, 스레드는 프로세스 안에서 실행되는 흐름 단위 입니다. 프로세스는 메모리와 CPU를 프로세스마다 할당받아서 사용하는데, 스레드는 프로세스 안에서 다른 스레드와 메모리와 CPU를 공유해서 사용합니다. 

<br/>

## CPU 스케줄러 
> 준비큐에 있는 프로세스에 대해 CPU를 할당하는 방법 <br/>
> CPU를 잘 사용하기 위해 프로세스를 잘 배정하기 

### 선점/비선점 스케줄링 
- 비선점 : 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장 <br/>
- 선점 : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우 

<br/>

### 프로세스 상태 
<p align="center"><img width="700" src="https://user-images.githubusercontent.com/29995318/228419742-9bf4edb2-1322-4a1a-b78c-4052ad7831c3.jpeg"></p>
- 비선점 스케줄링 : `I/O or Event Wait`, `Exit` <br/>
- 선점 스케줄링 : `Interrupt`, `I/O or Event Completion`, `I/O or Event Wait`, `Exit`

#### 프로세스 상태 전이 
- **승인(Admitted)** : 프로세스 생성이 가능하여 승인됨. 
- **스케줄러 디스패치 (Scheduler Dispatch)** : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것 
- **인터럽트 (Interrupt)** : 예외, 입출력, 이벤트 등이 발생하여 현재 실행 중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것
- **입출력 또는 이벤트 대기 (I/O or Event wait)** : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만드는 것. 
- **입출력 또는 이벤트 완료 (I/O or Event Completion)** : 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것 


### CPU 스케줄링의 종류 
- **비선점 스케줄링** : 프로세스가 CPU를 점유하고 있을 때, 이를 뺏을 수 없는 방식 
  - **FCFS(First Come First Served, First in First Out)** <br/>
    - 큐에 도착한 순서대로 CPU 할당 
    - 먼저 요청한 프로세스가 먼저 자원을 제공받으며 이미 사용중이라면 사용이 끝날때까지 기다려야하는 스케줄링 방식
    - 실행 시간이 짧은게 뒤로 가면 평균 대기 시간이 길어짐. 


  - **SJF(Shortest Job First)** <br/>
    - 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행 
    - 프로세스의 실행 시간을 이용하여 가장 짧은 시간을 갖는 프로세스가 먼저 자원을 할당받는 방식 
    - FCFS보다 평균 대기 시간 감소
    - 짧은 작업에 유리 

<br/>

- **선점 스케줄링** : 프로세스가 CPU를 할당받아 실행 중이더라도 OS가 이를 강제로 뺏을 수 있는 방식 
  - **Priority Scheduling**
    - 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리 
    - 우선 순위가 낮은 프로세스는 무한정 기다려야하는 Starvation이 생길 수 있음
    - Aging 방법으로 Starvation 문제 해결 가능
      - Aging: 해당 프로세스의 우선순위를 점차 높여 처리받게끔 함. 

  - **Round Robin**
    - 시분할 시스템을 위해 설계된 스케줄링 기법 
    - 작은 단위의 시간인 시간 할당량(Time-Slice)을 정의하여 그 시간만큼 자원을 할당하는 방식
    - 그 시간안에 작업을 끝내지 못하면 다음 프로세스가 다시 그 시간만큼 자원을 할당받아 사용함. 
    - 시간 할당량의 크기에 매우 많은 영향을 받는다. 
      - 시간 할당량이 매우 크면, FCFS와 같다. 
      - 시간 할당량이 매우 작으면, 매우 많은 문맥 교환을 야기한다. 

### CPU 스케줄러에 대해서 설명해보세요. 
준비큐에 있는 프로세스에 대해서 CPU를 할당하는 방법입니다. 크게 다섯가지가 있는데요, FCFS, SJF, SRT, Priority Scheduling, Round Robin이 있습니다. 

<br/>

## 데드락 
> 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태 <br/>
> 무한히 다음 자원을 기다리게 되는 상태 <br/>
> 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다. 

### 데드락 발생 조건 
아래 4가지가 모두 성립해야 데드락 발생 

1. **상호 배제** : 자원은 한번에 한 프로세스만 사용할 수 있음.
2. **점유 대기** : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함. 
3. **비선점** : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음. 
4. **순환 대기** : 프로세스의 집합에서 순환 형태로 자원을 대기하기 있어야 함. <br/> 
   프로세스의 집합 {P0, P1, ...  Pn}에서 P0는 P1이 점유한 자원을 대기하고, P1은 P2가 점유한 자원을 대기하고, ... , Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다. 

<br/>

### 데드락에 대해서 설명해보세요. 
데드락은 프로세스가 자원을 얻지 못해, 다음 작업을 못하는 상태입니다. <br/> 예를 들면, P1, P2가 각각 자원A와 자원B를 얻어야되는데  P1이 A, P2가 B를 가지고 있어서 서로 무한정 기다리는 상태를 데드락이라고 합니다. 데드락은 다음의 네가지 조건이 동시에 발생해야 성립이 가능한데요, 그 네가지는 상호배제, 점유대기, 비선점, 순환대기 입니다. 

<br/>

### 교착 상태를 예방&회피 
1. 예방(Prevention)
   교착 상태 발생 조건 중 하나를 제거하면서 해결한다. (자원 낭비 엄청 심함)
   - 상호배제 부정 : 여러 프로세스가 공유 자원 사용 
   - 점유대기 부정 : 프로세스 실행 전 모든 자원을 할당 
   - 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납 
   - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구 

2. 회피(Avoidance)
   교착 상태 발생 시 피해나가는 방법
   - 은행원 알고리즘 
     - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기 

